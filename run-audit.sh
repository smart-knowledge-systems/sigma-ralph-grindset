#!/usr/bin/env bash
set -euo pipefail

# ============================================================================
# Code Quality Audit Script
# ============================================================================
# Systematically identifies code quality issues against a specific policy.
# Results stored in SQLite database with policy tracking.
#
# Usage: ./run-audit.sh [--all] [--diff [ref]] [--max-loc N] <policy-name> [policy-name2 ...]
#        ./run-audit.sh -h|--help
# ============================================================================

# Shared library + path initialization
source "$(cd "$(dirname "$0")" && pwd)/lib.sh"
init_paths

# MAX_LOC is set by lib.sh init_paths (default 3000, overridable via audit.conf)

# ---------------------------------------------------------------------------
# Usage / help
# ---------------------------------------------------------------------------
show_help() {
    local script_name
    script_name=$(basename "$0")
    printf '%s\n' "Usage: ${script_name} [OPTIONS] <policy-name> [policy-name2 ...]"
    printf '%s\n' ""
    printf '%s\n' "Audit the codebase against one or more policies. Results are stored in"
    printf '%s\n' "SQLite database (audit.db) with per-issue policy tracking."
    printf '%s\n' ""
    printf '%s\n' "Options:"
    printf '%s\n' "  --all          Full audit (all branches, ignores checkpoints)"
    printf '%s\n' "  --diff [ref]   Audit only changed files (uncommitted, or since ref)"
    printf '%s\n' "  --max-loc N    Override maximum LOC per branch (default: ${MAX_LOC})"
    printf '%s\n' "  -h, --help     Show this help message and exit"
    printf '%s\n' ""
    printf '%s\n' "Arguments:"
    printf '%s\n' "  policy-name    One or more policy names from policies/ directory"
    printf '%s\n' ""
    printf '%s\n' "Examples:"
    printf '%s\n' "  ${script_name} vercel-react-best-practices"
    printf '%s\n' "  ${script_name} --all logging-strategy testing-philosophy"
    printf '%s\n' "  ${script_name} --diff my-policy              # Uncommitted changes only"
    printf '%s\n' "  ${script_name} --diff HEAD~1 my-policy       # Changes since last commit"
    printf '%s\n' "  ${script_name} --max-loc 2000 policy1 policy2 policy3"
    exit 0
}

# Argument parsing: optional --all flag, --diff flag, --max-loc flag + required policy name(s)
FORCE_ALL=""
DIFF_MODE=""
DIFF_REF=""
POLICY_NAMES=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h | --help) show_help ;;
        --all)
            FORCE_ALL=1
            shift
            ;;
        --diff)
            DIFF_MODE=1
            shift
            # Peek at next arg: if it's a valid git ref, consume it as DIFF_REF
            if [[ $# -gt 0 ]] && [[ "$1" != -* ]]; then
                if git -C "$PROJECT_ROOT" rev-parse --verify "$1^{}" &>/dev/null; then
                    DIFF_REF="$1"
                    shift
                fi
            fi
            ;;
        --max-loc)
            if [[ $# -lt 2 ]]; then
                log_error "--max-loc requires an argument"
                exit 2
            fi
            if ! [[ "$2" =~ ^[0-9]+$ ]] || [[ "$2" -eq 0 ]]; then
                log_error "--max-loc must be a positive integer, got: $2"
                exit 2
            fi
            MAX_LOC="$2"
            shift 2
            ;;
        -*)
            log_error "Unknown flag: $1"
            exit 1
            ;;
        *)
            POLICY_NAMES+=("$1")
            shift
            ;;
    esac
done

# Validate mutual exclusivity of --diff and --all
if [[ -n "$DIFF_MODE" ]] && [[ -n "$FORCE_ALL" ]]; then
    log_error "--diff and --all are mutually exclusive"
    exit 2
fi

if [[ ${#POLICY_NAMES[@]} -eq 0 ]]; then
    log_error "Usage: $0 [--all] [--max-loc N] <policy-name> [policy-name2 ...]"
    log_error ""
    log_error "Available policies:"
    for policy_dir in "${POLICIES_DIR}"/*/; do
        [[ ! -d "$policy_dir" ]] && continue
        dir_name=$(basename "$policy_dir")
        [[ -f "${policy_dir}POLICY.md" ]] && log_error "  - ${dir_name}"
    done
    exit 1
fi

# Validate all policies exist and build POLICY_LABEL
POLICY_LABEL=""
for policy_name in "${POLICY_NAMES[@]}"; do
    POLICY_FILE="${POLICIES_DIR}/${policy_name}/POLICY.md"
    if [[ ! -f "$POLICY_FILE" ]]; then
        log_error "Policy not found: ${policy_name}. Checked location: ${POLICY_FILE}"
        log_error ""
        log_error "Available policies:"
        for policy_dir in "${POLICIES_DIR}"/*/; do
            [[ ! -d "$policy_dir" ]] && continue
            dir_name=$(basename "$policy_dir")
            [[ -f "${policy_dir}POLICY.md" ]] && log_error "  - ${dir_name}"
        done
        exit 1
    fi
    if [[ -z "$POLICY_LABEL" ]]; then
        POLICY_LABEL="$policy_name"
    else
        POLICY_LABEL="${POLICY_LABEL}|${policy_name}"
    fi
done

readonly MAX_LOC
readonly POLICY_LABEL

# Branch list (generated by generate-branches.sh → branches.txt)
# Skipped in diff mode — files come from git diff instead
BRANCHES=()
if [[ -z "$DIFF_MODE" ]]; then
    if [[ ! -f "$BRANCHES_FILE" ]]; then
        log_error "${BRANCHES_FILE} not found. Run generate-branches.sh first."
        exit 1
    fi
    while IFS= read -r line; do
        [[ -n "$line" ]] && BRANCHES+=("$line")
    done <"$BRANCHES_FILE"
fi

# Temp file tracking for cleanup on unexpected exit (global array)
declare -a TEMP_FILES=()

cleanup() {
    local f
    if [[ ${#TEMP_FILES[@]} -gt 0 ]]; then
        for f in "${TEMP_FILES[@]}"; do
            rm -f "$f"
        done
    fi
    progress_cleanup
}

# Progress footer
source "${AUDIT_DIR}/progress.sh"
progress_init
if progress_is_owner; then
    # progress_total is set later in main() after branch filtering
    trap 'cleanup' EXIT INT TERM
fi
if [[ ${#POLICY_NAMES[@]} -eq 1 ]]; then
    progress_title "Audit: ${POLICY_LABEL}"
else
    progress_title "Audit: combined (${#POLICY_NAMES[@]} policies)"
fi

# JSON Schema for Claude output validation
readonly JSON_SCHEMA='
{
  "type": "object",
  "properties": {
    "issues": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "description": { "type": "string" },
          "rule": { "type": "string" },
          "severity": { "type": "string", "enum": ["high", "medium", "low"] },
          "suggestion": { "type": "string" },
          "policy": { "type": "string" },
          "files": {
            "type": "array",
            "items": { "type": "string" },
            "minItems": 1
          }
        },
        "required": ["description", "rule", "severity", "suggestion", "policy", "files"],
        "additionalProperties": false
      }
    }
  },
  "required": ["issues"],
  "additionalProperties": false
}
'

# ============================================================================
# Helper Functions
# ============================================================================

# Determine which branches have changed since the last checkpoint for policies.
# Returns one of: NO_CHECKPOINT, INVALID_CHECKPOINT, NO_CHANGES, or
# newline-separated list of changed branch paths (cleaned, no "(flat)" suffix).
# Accepts multiple policy names as arguments.
get_changed_branches() {
    # Build IN clause for SQL query
    local in_clause=""
    local policy
    for policy in "$@"; do
        if [[ -z "$in_clause" ]]; then
            in_clause="'$(sql_escape "$policy")'"
        else
            in_clause="${in_clause},'$(sql_escape "$policy")'"
        fi
    done

    # Query oldest checkpoint across ALL given policies
    local checkpoint_commit
    checkpoint_commit=$(db "SELECT git_commit FROM audit_checkpoints WHERE policy IN (${in_clause}) ORDER BY completed_at ASC LIMIT 1;")

    if [[ -z "$checkpoint_commit" ]]; then
        printf '%s\n' "NO_CHECKPOINT"
        return
    fi

    # Verify commit exists in git history
    if ! git -C "$PROJECT_ROOT" cat-file -t "$checkpoint_commit" &>/dev/null; then
        printf '%s\n' "INVALID_CHECKPOINT"
        return
    fi

    # Get changed files since checkpoint
    local changed_files
    changed_files=$(git -C "$PROJECT_ROOT" diff --name-only "${checkpoint_commit}...HEAD" 2>/dev/null || true)

    if [[ -z "$changed_files" ]]; then
        printf '%s\n' "NO_CHANGES"
        return
    fi

    # Filter to matching extensions and map to branches (bash 3.2 compatible)
    local changed_branches=""
    while IFS= read -r file; do
        if ! matches_extensions "$file"; then
            continue
        fi
        if is_excluded_path "$file"; then
            continue
        fi

        local branch
        branch=$(file_to_branch "$file")
        if [[ -n "$branch" ]]; then
            changed_branches="${changed_branches}${branch}"$'\n'
        fi
    done <<<"$changed_files"

    # Deduplicate and check for empty
    changed_branches=$(printf '%s' "$changed_branches" | sort -u | sed '/^$/d')

    if [[ -z "$changed_branches" ]]; then
        printf '%s\n' "NO_CHANGES"
        return
    fi

    # Return unique branch paths
    printf '%s\n' "$changed_branches"
}

# ============================================================================
# Build System Prompt
# ============================================================================

build_system_prompt() {
    local temp_file
    temp_file=$(mktemp)

    cat >"$temp_file" <<'PROMPT'
You are a code quality auditor specializing in React and TypeScript best practices.

## Your Task
Review the provided code and identify violations of the guidelines below. For each issue found:

1. Provide a clear description of the problem
2. Reference the specific rule name from the guidelines
3. Assign severity: high (performance/correctness issues), medium (maintainability concerns), low (style/minor improvements)
4. Suggest a concrete fix
5. List all affected files
6. Tag with the specific policy name that was violated (from the guideline sections below)

## Severity Mapping
- **high**: Performance problems, bugs, incorrect patterns that could break functionality
- **medium**: Maintainability issues, code smells, suboptimal patterns
- **low**: Style improvements, minor optimizations, cosmetic issues

## Output Constraints
- Focus on actionable issues that can be fixed
- Don't report issues for intentional design decisions (e.g., acceptable use of any for external data before Zod validation)
- Prioritize issues that improve readability and maintainability
- Each issue must include at least one file path
- For the policy field, use the exact policy name from the section headers below (e.g., "vercel-react-best-practices", "logging-strategy")

PROMPT

    local policy_name
    local policy_file
    local policies_loaded=0
    for policy_name in "$@"; do
        policy_file="${POLICIES_DIR}/${policy_name}/POLICY.md"
        if [[ ! -f "$policy_file" ]]; then
            log_warn "Policy file not found: ${policy_file}, skipping"
            continue
        fi
        if [[ ! -r "$policy_file" ]]; then
            log_warn "Policy file not readable: ${policy_file}, skipping"
            continue
        fi
        if [[ ! -s "$policy_file" ]]; then
            log_warn "Policy file is empty: ${policy_file}, skipping"
            continue
        fi
        printf '\n## Guidelines: %s\n\n' "$policy_name" >>"$temp_file"
        cat "$policy_file" >>"$temp_file"
        ((policies_loaded++)) || true
    done

    if [[ $policies_loaded -eq 0 ]]; then
        log_error "No valid policy files loaded in build_system_prompt"
        rm -f "$temp_file"
        return 1
    fi

    printf '%s\n' "$temp_file"
}

# ============================================================================
# Process Branch
# ============================================================================

process_branch() {
    local branch="$1"
    local batch_suffix="${2:-}"
    shift 2
    local -a files=("$@")

    local branch_label="$branch${batch_suffix}"

    # Supersede pending issues for this branch+policy (handles batch suffixes and combined policy labels)
    # Build IN clause for individual policy names OR the combined label
    local policy_in_clause=""
    for policy_name in "${POLICY_NAMES[@]}"; do
        if [[ -z "$policy_in_clause" ]]; then
            policy_in_clause="'$(sql_escape "$policy_name")'"
        else
            policy_in_clause="${policy_in_clause},'$(sql_escape "$policy_name")'"
        fi
    done
    policy_in_clause="${policy_in_clause},'$(sql_escape "$POLICY_LABEL")'"

    local superseded_count
    superseded_count=$(db "
        UPDATE issues SET fix_status = 'superseded'
        WHERE fix_status = 'pending'
          AND scan_id IN (
              SELECT id FROM scans
              WHERE (branch_path = '$(sql_escape "$branch")' OR branch_path LIKE '$(sql_escape "$branch") [batch %]')
                AND policy IN (${policy_in_clause})
          );
        SELECT changes();
    ")
    if [[ "$superseded_count" -gt 0 ]]; then
        printf '%s\n' "  Superseded ${superseded_count} stale issues for ${branch} [${POLICY_LABEL}]"
    fi

    log_info "Processing: $branch_label (${#files[@]} files)"

    # Calculate total LOC
    local total_loc
    total_loc=$(count_loc "${files[@]}")

    # Create scan record
    local scan_id
    scan_id=$(db "INSERT INTO scans (branch_path, policy, file_count, total_loc) VALUES ('$(sql_escape "$branch_label")', '$(sql_escape "$POLICY_LABEL")', ${#files[@]}, $total_loc); SELECT last_insert_rowid();")

    # Build prompt using literal newlines (not \n escapes) so we can use
    # printf '%s' instead of '%b', which would corrupt backslash sequences
    # in source file contents.
    local prompt
    prompt=$'# Code Quality Review: '"${branch_label}"$'\n\n'
    prompt+="Review the following ${#files[@]} files from the \`${branch}\` directory."$'\n\n'

    # Add file contents
    prompt+=$'## File Contents\n\n'
    local file rel_path
    for file in "${files[@]}"; do
        rel_path="${file#"${PROJECT_ROOT}"/}"
        prompt+="\`\`\`$(ext_to_lang):${rel_path}"$'\n'
        prompt+="$(<"$file")"$'\n'
        prompt+="\`\`\`"$'\n\n'
    done

    # Add dependencies
    prompt+=$'## Dependencies (imported)\n\n'
    local all_imports=()
    for file in "${files[@]}"; do
        while IFS= read -r import; do
            all_imports+=("$import")
        done < <(extract_imports "$file")
    done

    if [[ ${#all_imports[@]} -gt 0 ]]; then
        local sorted_imports
        sorted_imports=$(printf '%s\n' "${all_imports[@]}" | sort -u)
        while read -r import; do
            prompt+="- \`${import}\`"$'\n'
        done <<<"$sorted_imports"
    else
        prompt+=$'(none)\n'
    fi

    prompt+=$'\n## Instructions\n\n'
    prompt+="Identify code quality issues following the guidelines provided in the system prompt. "
    prompt+=$'Return your findings in the specified JSON schema format.\n'

    # Build system prompt with all policies (tracked for cleanup on exit)
    local system_prompt_file
    system_prompt_file=$(build_system_prompt "${POLICY_NAMES[@]}")
    TEMP_FILES+=("$system_prompt_file")

    # Call Claude CLI
    local output
    local claude_exit_code=0
    output=$(printf '%s' "$prompt" | claude \
        --print \
        --no-session-persistence \
        --model "$AUDIT_MODEL" \
        --output-format json \
        --max-turns 100 \
        --json-schema "$JSON_SCHEMA" \
        --append-system-prompt "$(cat "$system_prompt_file")" 2>&1) || claude_exit_code=$?

    # Clean up temp file
    rm -f "$system_prompt_file"

    # Check for errors — store only exit code and a truncated message
    # (raw stderr may contain request details or auth-related info)
    if [[ $claude_exit_code -ne 0 ]]; then
        local truncated_err
        truncated_err=$(truncate_for_db "$output" 500)
        local error_msg
        error_msg="exit_code=${claude_exit_code}: $(sql_escape "$truncated_err")"
        db "UPDATE scans SET status='failed', error_message='$error_msg', completed_at=strftime('%Y-%m-%dT%H:%M:%SZ', 'now') WHERE id=$scan_id;"
        log_error "Claude CLI failed for ${branch_label} (exit code ${claude_exit_code})"
        return 1
    fi

    # Parse JSON output (structured_output contains the schema-validated data)
    local result_json
    result_json=$(printf '%s\n' "$output" | jq -c '.structured_output' 2>/dev/null) || {
        db "UPDATE scans SET status='failed', error_message='JSON parse error', completed_at=strftime('%Y-%m-%dT%H:%M:%SZ', 'now') WHERE id=$scan_id;"
        log_error "Failed to parse JSON for ${branch_label}"
        return 1
    }

    # Insert issues into database
    local issue_count=0
    while read -r issue; do
        local description severity rule suggestion policy
        description=$(printf '%s\n' "$issue" | jq -r '.description')
        severity=$(printf '%s\n' "$issue" | jq -r '.severity')
        rule=$(printf '%s\n' "$issue" | jq -r '.rule')
        suggestion=$(printf '%s\n' "$issue" | jq -r '.suggestion')
        policy=$(printf '%s\n' "$issue" | jq -r '.policy')

        # Escape for SQL
        description=$(sql_escape "$description")
        rule=$(sql_escape "$rule")
        suggestion=$(sql_escape "$suggestion")
        policy=$(sql_escape "$policy")

        # Insert issue
        local issue_id
        issue_id=$(db "INSERT INTO issues (scan_id, description, rule, severity, suggestion, policy) VALUES ($scan_id, '$description', '$rule', '$severity', '$suggestion', '$policy'); SELECT last_insert_rowid();")

        # Insert file associations (process substitution keeps loop in main shell)
        local raw_file_path file_id clean_path lines
        while read -r raw_file_path; do
            parse_file_ref "$raw_file_path"
            clean_path=$(sql_escape "$PARSED_PATH")
            lines=$(sql_escape "$PARSED_LINES")
            db "INSERT OR IGNORE INTO files (path) VALUES ('$clean_path');"
            file_id=$(db "SELECT id FROM files WHERE path='$clean_path';")
            db "INSERT OR IGNORE INTO issue_files (issue_id, file_id, lines) VALUES ($issue_id, $file_id, '$lines');"
        done < <(printf '%s\n' "$issue" | jq -r '.files[]')

        ((issue_count++)) || true
    done < <(printf '%s\n' "$result_json" | jq -c '.issues[]' 2>/dev/null)

    # Update scan as completed
    db "UPDATE scans SET status='completed', issue_count=$issue_count, completed_at=strftime('%Y-%m-%dT%H:%M:%SZ', 'now') WHERE id=$scan_id;"

    printf '%s\n' "  ✓ Completed: $issue_count issues found"

    # Rate limiting
    sleep 2
}

# ============================================================================
# Main Processing Loop (split into focused helper functions)
# ============================================================================

# Pre-scan total LOC across all branches to configure progress tracking.
# Args: branch names as positional arguments
# Output: total LOC count to stdout
prescan_loc() {
    local total=0
    local branch
    local prescan_branch
    local prescan_flat
    local prescan_path
    local prescan_files
    local prescan_loc
    local f

    for branch in "$@"; do
        prescan_branch="$branch"
        prescan_flat=""
        if [[ "$branch" =~ ^(.*)[[:space:]]\(flat\)$ ]]; then
            prescan_branch="${BASH_REMATCH[1]}"
            prescan_flat="flat"
        fi
        prescan_path="${PROJECT_ROOT}/${prescan_branch}"
        if [[ -d "$prescan_path" ]]; then
            prescan_files=()
            while IFS= read -r f; do
                prescan_files+=("$f")
            done < <(find_source_files "$prescan_path" "$prescan_flat")
            if [[ ${#prescan_files[@]} -gt 0 ]]; then
                prescan_loc=$(count_loc "${prescan_files[@]}")
                total=$((total + prescan_loc))
            fi
        fi
    done
    printf '%s\n' "$total"
}

# Process all branches in AUDIT_BRANCHES, dispatching to process_branch
# (single or batched). Sets RESULT_* globals for the summary.
#
# Globals read:  AUDIT_BRANCHES, PROJECT_ROOT, POLICY_LABEL, POLICY_NAMES, MAX_LOC
# Globals written: RESULT_PROCESSED, RESULT_SUCCESS, RESULT_FAIL
process_all_branches() {
    local total_audit_loc="$1"

    local loc_done=0
    local branch_index=0
    RESULT_PROCESSED=0
    RESULT_SUCCESS=0
    RESULT_FAIL=0

    local branch is_flat clean_branch full_path
    for branch in "${AUDIT_BRANCHES[@]}"; do
        ((branch_index++)) || true

        # Parse (flat) suffix
        is_flat=""
        clean_branch="$branch"
        if [[ "$branch" =~ ^(.*)[[:space:]]\(flat\)$ ]]; then
            clean_branch="${BASH_REMATCH[1]}"
            is_flat="flat"
        fi

        # Update progress footer
        if progress_is_owner; then
            progress_set "$loc_done" "${clean_branch}"
        else
            progress_substep "$loc_done" "$total_audit_loc" "${clean_branch}"
        fi

        full_path="${PROJECT_ROOT}/${clean_branch}"

        # Check if path exists
        if [[ ! -d "$full_path" ]]; then
            log_warn "Skipping ${branch}: directory not found at ${full_path}"
            db "INSERT INTO scans (branch_path, policy, status) VALUES ('$(sql_escape "$branch")', '$(sql_escape "$POLICY_LABEL")', 'skipped');"
            continue
        fi

        # Find files (pass is_flat flag)
        local files=()
        while IFS= read -r file; do
            files+=("$file")
        done < <(find_source_files "$full_path" "$is_flat")

        # Skip if no files
        if [[ ${#files[@]} -eq 0 ]]; then
            log_warn "Skipping: $branch (no $(ext_display_label) files found)"
            db "INSERT INTO scans (branch_path, policy, status, file_count, total_loc) VALUES ('$(sql_escape "$branch")', '$(sql_escape "$POLICY_LABEL")', 'skipped', 0, 0);"
            continue
        fi

        # Check LOC limit
        local total_loc
        total_loc=$(count_loc "${files[@]}")

        ((RESULT_PROCESSED++)) || true
        if [[ $total_loc -le $MAX_LOC ]]; then
            # Process as single batch
            if process_branch "$branch" "" "${files[@]}"; then
                ((RESULT_SUCCESS++)) || true
            else
                ((RESULT_FAIL++)) || true
            fi
            loc_done=$((loc_done + total_loc))
            if progress_is_owner; then
                progress_set "$loc_done" "${clean_branch}"
            else
                progress_substep "$loc_done" "$total_audit_loc" "${clean_branch}"
            fi
        else
            # Split into batches
            log_info "Branch ${branch} exceeds LOC limit (${total_loc} > ${MAX_LOC}), splitting into batches"

            local batch_num=1
            local batch_files=()
            local batch_loc=0
            local branch_failed=""

            local file file_loc
            for file in "${files[@]}"; do
                file_loc=$(wc -l <"$file" 2>/dev/null) || {
                    log_warn "Cannot read file: $file, skipping"
                    continue
                }

                # Check if adding this file would exceed limit
                if [[ $((batch_loc + file_loc)) -gt $MAX_LOC ]] && [[ ${#batch_files[@]} -gt 0 ]]; then
                    # Process current batch
                    process_branch "$branch" " [batch $batch_num]" "${batch_files[@]}" || branch_failed=1
                    loc_done=$((loc_done + batch_loc))
                    if progress_is_owner; then
                        progress_set "$loc_done" "${clean_branch}"
                    else
                        progress_substep "$loc_done" "$total_audit_loc" "${clean_branch}"
                    fi

                    # Start new batch
                    ((batch_num++)) || true
                    batch_files=("$file")
                    batch_loc=$file_loc
                else
                    # Add to current batch
                    batch_files+=("$file")
                    batch_loc=$((batch_loc + file_loc))
                fi
            done

            # Process remaining batch
            if [[ ${#batch_files[@]} -gt 0 ]]; then
                process_branch "$branch" " [batch $batch_num]" "${batch_files[@]}" || branch_failed=1
                loc_done=$((loc_done + batch_loc))
                if progress_is_owner; then
                    progress_set "$loc_done" "${clean_branch}"
                else
                    progress_substep "$loc_done" "$total_audit_loc" "${clean_branch}"
                fi
            fi

            if [[ -n "$branch_failed" ]]; then
                ((RESULT_FAIL++)) || true
            else
                ((RESULT_SUCCESS++)) || true
            fi
        fi

        printf '%s\n' ""
    done
}

# Print a structured summary of the audit run.
# Args: $1=elapsed_seconds $2=processed_count $3=success_count
#       $4=fail_count $5=skipped_count
print_summary() {
    local elapsed="$1"
    local processed_count="$2"
    local success_count="$3"
    local fail_count="$4"
    local skipped_count="$5"

    printf '%s\n' ""
    printf '%s\n' "=============================="
    if [[ ${#POLICY_NAMES[@]} -eq 1 ]]; then
        printf '%s\n' "Audit Summary — Policy: ${POLICY_LABEL}"
    else
        printf '%s\n' "Audit Summary — Combined (${#POLICY_NAMES[@]} policies)"
    fi
    printf '%s\n' "=============================="
    printf '%s\n' ""
    printf '%s\n' "Branches processed: ${processed_count} (${success_count} succeeded, ${fail_count} failed)"
    if [[ $skipped_count -gt 0 ]]; then
        printf '%s\n' "Branches skipped:   ${skipped_count} (unchanged)"
    fi
    printf '%s\n' "Duration: ${elapsed}s"
    printf '%s\n' ""

    printf '%s\n' "## Scans by Status"
    db -column -header "SELECT status, COUNT(*) as count FROM scans WHERE policy='$(sql_escape "$POLICY_LABEL")' GROUP BY status;"
    printf '%s\n' ""

    printf '%s\n' "## Issues by Severity"
    db -column -header "SELECT severity, COUNT(*) as count FROM issues i JOIN scans s ON i.scan_id = s.id WHERE s.policy='$(sql_escape "$POLICY_LABEL")' GROUP BY severity ORDER BY CASE severity WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END;"
    printf '%s\n' ""

    printf '%s\n' "## Top 20 Rules (by frequency)"
    db -column -header "SELECT rule, COUNT(*) as count FROM issues i JOIN scans s ON i.scan_id = s.id WHERE s.policy='$(sql_escape "$POLICY_LABEL")' GROUP BY rule ORDER BY count DESC LIMIT 20;"
    printf '%s\n' ""

    printf '%s\n' "## Top 15 Most Affected Files"
    db -column -header "SELECT f.path, COUNT(*) as issue_count FROM issue_files jf JOIN files f ON jf.file_id = f.id JOIN issues i ON jf.issue_id = i.id JOIN scans s ON i.scan_id = s.id WHERE s.policy='$(sql_escape "$POLICY_LABEL")' GROUP BY f.path ORDER BY issue_count DESC LIMIT 15;"
    printf '%s\n' ""

    printf '%s\n' "## Issues by Policy (all policies)"
    db -column -header "SELECT s.policy, COUNT(i.id) as issue_count FROM scans s LEFT JOIN issues i ON i.scan_id = s.id WHERE s.policy != '' GROUP BY s.policy ORDER BY issue_count DESC;"
    printf '%s\n' ""

    if [[ ${#POLICY_NAMES[@]} -eq 1 ]]; then
        printf '%s\n' "✓ Audit complete for policy '${POLICY_LABEL}'. Results saved to: $DB_PATH"
    else
        printf '%s\n' "✓ Audit complete for combined policies. Results saved to: $DB_PATH"
    fi
}

main() {
    local start_time
    start_time=$(date +%s)

    if [[ ${#POLICY_NAMES[@]} -eq 1 ]]; then
        printf '%s\n' "Code Quality Audit — Policy: ${POLICY_LABEL}"
    else
        printf '%s\n' "Code Quality Audit — Combined (${#POLICY_NAMES[@]} policies)"
    fi
    printf '%s\n' "============================================="
    printf '%s\n' ""

    # Initialize database
    printf '%s\n' "Initializing database at: $DB_PATH"
    init_database
    printf '%s\n' ""

    local AUDIT_BRANCHES=()
    local skipped_count=0

    if [[ -n "$DIFF_MODE" ]]; then
        # --- Diff mode: audit only changed files ---
        local diff_label="(diff)"
        if [[ -n "$DIFF_REF" ]]; then
            diff_label="(diff:${DIFF_REF})"
        fi

        if [[ -n "$DIFF_REF" ]]; then
            printf '%s\n' "Mode: diff (changes since ${DIFF_REF})"
        else
            printf '%s\n' "Mode: diff (uncommitted changes)"
        fi

        # Collect changed files
        local diff_files=()
        local f
        while IFS= read -r f; do
            [[ -n "$f" ]] && diff_files+=("$f")
        done < <(get_diff_files "$DIFF_REF")

        if [[ ${#diff_files[@]} -eq 0 ]]; then
            progress_pause
            printf '%s\n' ""
            printf '%s\n' "No matching changed files found — nothing to audit."
            return 0
        fi

        printf '%s\n' "Changed files: ${#diff_files[@]}"
        printf '%s\n' ""

        # Calculate total LOC for progress
        local total_audit_loc
        total_audit_loc=$(count_loc "${diff_files[@]}")

        if progress_is_owner; then
            progress_total "$total_audit_loc"
            progress_unit "LOC"
        fi

        # Batch files by MAX_LOC and process each batch
        RESULT_PROCESSED=0
        RESULT_SUCCESS=0
        RESULT_FAIL=0

        local batch_num=1
        local batch_files=()
        local batch_loc=0
        local loc_done=0

        local file file_loc
        for file in "${diff_files[@]}"; do
            file_loc=$(wc -l <"$file" 2>/dev/null) || {
                log_warn "Cannot read file: $file, skipping"
                continue
            }

            if [[ $((batch_loc + file_loc)) -gt $MAX_LOC ]] && [[ ${#batch_files[@]} -gt 0 ]]; then
                # Process current batch
                ((RESULT_PROCESSED++)) || true
                if process_branch "$diff_label" " [batch $batch_num]" "${batch_files[@]}"; then
                    ((RESULT_SUCCESS++)) || true
                else
                    ((RESULT_FAIL++)) || true
                fi
                loc_done=$((loc_done + batch_loc))
                if progress_is_owner; then
                    progress_set "$loc_done" "${diff_label}"
                fi

                ((batch_num++)) || true
                batch_files=("$file")
                batch_loc=$file_loc
            else
                batch_files+=("$file")
                batch_loc=$((batch_loc + file_loc))
            fi
        done

        # Process remaining batch
        if [[ ${#batch_files[@]} -gt 0 ]]; then
            ((RESULT_PROCESSED++)) || true
            local suffix=""
            if [[ $batch_num -gt 1 ]]; then
                suffix=" [batch $batch_num]"
            fi
            if process_branch "$diff_label" "$suffix" "${batch_files[@]}"; then
                ((RESULT_SUCCESS++)) || true
            else
                ((RESULT_FAIL++)) || true
            fi
            loc_done=$((loc_done + batch_loc))
            if progress_is_owner; then
                progress_set "$loc_done" "${diff_label}"
            fi
        fi

        # Generate summary report
        progress_pause
        local elapsed=$(($(date +%s) - start_time))
        print_summary "$elapsed" "$RESULT_PROCESSED" "$RESULT_SUCCESS" "$RESULT_FAIL" "$skipped_count"
        progress_resume
    else
        # --- Normal mode: branch-based audit ---
        # Load branch definitions for file→branch mapping
        load_branches_for_matching

        # Determine which branches to audit (incremental vs full)
        if [[ -n "$FORCE_ALL" ]]; then
            printf '%s\n' "Mode: full audit (--all)"
            AUDIT_BRANCHES=("${BRANCHES[@]}")
        else
            local changed_result
            changed_result=$(get_changed_branches "${POLICY_NAMES[@]}")

            case "$changed_result" in
                NO_CHECKPOINT)
                    printf '%s\n' "Mode: full audit (no previous checkpoint)"
                    AUDIT_BRANCHES=("${BRANCHES[@]}")
                    ;;
                INVALID_CHECKPOINT)
                    printf '%s\n' "Mode: full audit (checkpoint commit no longer in history)"
                    AUDIT_BRANCHES=("${BRANCHES[@]}")
                    ;;
                NO_CHANGES)
                    progress_pause
                    printf '%s\n' "No $(ext_display_label) files changed since last audit — nothing to do."
                    printf '%s\n' ""
                    if [[ ${#POLICY_NAMES[@]} -eq 1 ]]; then
                        printf '%s\n' "✓ Audit skipped for policy '${POLICY_LABEL}' (no changes). Use --all to force."
                    else
                        printf '%s\n' "✓ Audit skipped for combined policies (no changes). Use --all to force."
                    fi
                    return 0
                    ;;
                *)
                    # Build a set of changed branch paths for filtering (bash 3.2 compatible)
                    local changed_set=""
                    while IFS= read -r cb; do
                        [[ -n "$cb" ]] && changed_set="${changed_set}${cb}"$'\n'
                    done <<<"$changed_result"

                    local branch clean_branch
                    for branch in "${BRANCHES[@]}"; do
                        clean_branch="$branch"
                        if [[ "$branch" =~ ^(.*)[[:space:]]\(flat\)$ ]]; then
                            clean_branch="${BASH_REMATCH[1]}"
                        fi

                        if printf '%s\n' "$changed_set" | grep -qxF "$clean_branch"; then
                            AUDIT_BRANCHES+=("$branch")
                        else
                            ((skipped_count++)) || true
                        fi
                    done

                    printf '%s\n' "Mode: incremental (${#AUDIT_BRANCHES[@]} changed, ${skipped_count} skipped)"
                    ;;
            esac
        fi
        printf '%s\n' ""

        # Pre-scan total LOC and configure progress
        local total_audit_loc
        total_audit_loc=$(prescan_loc "${AUDIT_BRANCHES[@]}")

        if progress_is_owner; then
            progress_total "$total_audit_loc"
            progress_unit "LOC"
        fi

        # Process all branches
        process_all_branches "$total_audit_loc"

        # Generate summary report (pause footer to prevent cursor interference)
        progress_pause
        local elapsed=$(($(date +%s) - start_time))
        print_summary "$elapsed" "$RESULT_PROCESSED" "$RESULT_SUCCESS" "$RESULT_FAIL" "$skipped_count"
        progress_resume
    fi
}

# Run main
main "$@"
